/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/
/**

/**
To understand the port definitions in C, we remember #define is simply a copy paste. E.g.,

    #define PD12   (*((volatile unsigned long *)0x40004080))
    data = PD12;

becomes

    data = (*((volatile unsigned long *)0x40004080));

To understand why we define ports this way, let’s break this port definition into pieces. First, 0x40004080 is the address of Port D bit 12. If we write just #define PD12 0x40004080 it will create

    data = 0x40004080;

which does not read the contents of PD12 as desired. This means we need to dereference the address. If we write #define PD12 (*0x40004080) it will create

    data = (*0x40004080);

This will attempt to read the contents at 0x40004080, but doesn’t know whether to read 8, 16, or 32 bits. So the compiler gives a syntax error because the type of data does not match the type of (*0x40004080).  To solve a type mismatch in C we typecast, placing a (new type) in front of the object we wish to convert. We wish force the type conversion to unsigned 32 bits, so we modify the definition to include the typecast. 

The volatile is added because the value of a port can change beyond the direct action of the software. It forces the C compiler to read a new value each time through a loop and not rely on the previous value.  
#define PD12   (*((volatile unsigned long *)0x40004080))
void wait(void){
  while((PD12&0x20)==0){};
}
void wait2(void){
  while(((*((volatile unsigned long *)0x40004080))&0x20)==0){};
}
void wait3(void){
  volatile unsigned long *pt;
  pt = ((volatile unsigned long *)0x40004080);
  while(((*pt)&0x20)==0){};

*/
*/
#include<stdint.h>

int main(void)
{													//Pg 51, 52, 166, 243, 244
	uint32_t *pClkCtrlReg =   (uint32_t*)0x40021014;//0x40021000 [BASE] + 0x14 [OFFSET]
	uint32_t *pPortEModeReg = (uint32_t*)0x48001000;//0x48001000 [BASE] + 0x00 [OFFSET]
	uint32_t *pPortEOutReg =  (uint32_t*)0x48001014;//0x48001000 [BASE] + 0x14 [OFFSET]

	//1. enable the clock for GPOIE peripheral in the AHBENR (SET the 21st bit position)
	*pClkCtrlReg |= ( 1 << 21);

	//2. configure the mode of the IO pin 8 as output
	//a. clear the 16th and 17th bit positions (CLEAR)
	*pPortEModeReg &= ~( 3 << 18);
	//b. make 16th bit position as 1 (SET)
	*pPortEModeReg |= ( 1 << 18);

	//3.SET 9th bit of the output data register to make I/O pin-9 as HIGH
	//*pPortEOutReg |= ( 1 << 9);

	while(1)
		{
			//3.SET 9th bit of the output data register to make I/O pin-12 as HIGH
			*pPortEOutReg |= ( 1 << 9);

			//introduce small human observable delay
			//This loop executes for 10K times
			for(uint32_t i=0 ; i < 300000 ; i++ );

			//Turn OFF the LED
			*pPortEOutReg &= ~( 1 << 9);

			for(uint32_t i=0 ; i < 300000 ; i++ );
		}
}
